<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Diego Fernando Chávez Henao, dfchavez@unal.edu.co">
<meta name="author" content="Alejandro Feria González, aferiag@unal.edu.co">
<meta name="author" content="Santiago Molina Muñoz, smolinam@unal.edu.co">
<meta name="author" content="Juan Manuel Teherán Machado, jteheranm@unal.edu.co">
<meta name="dcterms.date" content="2024-06-12">

<title>Modelado de Riesgo Crediticio con Redes Neuronales – Redes Neuronales y Algoritmos Bioinspirados. Grupo 8</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<link href="../../site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet">

<script src="../../site_libs/pagedtable-1.1/js/pagedtable.js"></script>


  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<link rel="stylesheet" href="custom.css">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Redes Neuronales y Algoritmos Bioinspirados. Grupo 8</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-right">
      <h1 class="title">Modelado de Riesgo Crediticio con Redes Neuronales</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Redes Neuronales</div>
                <div class="quarto-category">Riesgo crediticio</div>
                <div class="quarto-category">Árbol de decisión</div>
                <div class="quarto-category">Modelación</div>
                <div class="quarto-category">Python</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-right">

      <div>
      <div class="quarto-title-meta-heading">Authors</div>
      <div class="quarto-title-meta-contents">
               <p>Diego Fernando Chávez Henao, dfchavez@unal.edu.co </p>
               <p>Alejandro Feria González, aferiag@unal.edu.co </p>
               <p>Santiago Molina Muñoz, smolinam@unal.edu.co </p>
               <p>Juan Manuel Teherán Machado, jteheranm@unal.edu.co </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">June 12, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Tabla de contenido</h2>
   
  <ul>
  <li><a href="#introducción" id="toc-introducción" class="nav-link active" data-scroll-target="#introducción"><span class="header-section-number">1</span> <strong>Introducción</strong></a></li>
  <li><a href="#marco-teórico" id="toc-marco-teórico" class="nav-link" data-scroll-target="#marco-teórico"><span class="header-section-number">2</span> <strong>Marco Teórico</strong></a>
  <ul class="collapse">
  <li><a href="#riesgo-crediticio" id="toc-riesgo-crediticio" class="nav-link" data-scroll-target="#riesgo-crediticio"><span class="header-section-number">2.1</span> Riesgo crediticio</a>
  <ul class="collapse">
  <li><a href="#métodos-para-estimar-el-riesgo-crediticio" id="toc-métodos-para-estimar-el-riesgo-crediticio" class="nav-link" data-scroll-target="#métodos-para-estimar-el-riesgo-crediticio"><span class="header-section-number">2.1.1</span> Métodos para estimar el riesgo crediticio</a></li>
  </ul></li>
  <li><a href="#redes-neuronales-artificiales-rna" id="toc-redes-neuronales-artificiales-rna" class="nav-link" data-scroll-target="#redes-neuronales-artificiales-rna"><span class="header-section-number">2.2</span> Redes Neuronales Artificiales (RNA)</a>
  <ul class="collapse">
  <li><a href="#conceptos-clave-en-rna" id="toc-conceptos-clave-en-rna" class="nav-link" data-scroll-target="#conceptos-clave-en-rna"><span class="header-section-number">2.2.1</span> Conceptos clave en RNA</a></li>
  <li><a href="#rna-en-el-riesgo-crediticio" id="toc-rna-en-el-riesgo-crediticio" class="nav-link" data-scroll-target="#rna-en-el-riesgo-crediticio"><span class="header-section-number">2.2.2</span> RNA en el riesgo crediticio</a></li>
  <li><a href="#ejemplo-básico-en-python" id="toc-ejemplo-básico-en-python" class="nav-link" data-scroll-target="#ejemplo-básico-en-python"><span class="header-section-number">2.2.3</span> Ejemplo básico en Python</a></li>
  </ul></li>
  <li><a href="#scorecards-y-explicabilidad" id="toc-scorecards-y-explicabilidad" class="nav-link" data-scroll-target="#scorecards-y-explicabilidad"><span class="header-section-number">2.3</span> Scorecards y explicabilidad</a>
  <ul class="collapse">
  <li><a href="#fórmula-estándar-para-scorecards" id="toc-fórmula-estándar-para-scorecards" class="nav-link" data-scroll-target="#fórmula-estándar-para-scorecards"><span class="header-section-number">2.3.1</span> Fórmula estándar para scorecards</a></li>
  </ul></li>
  <li><a href="#metodología-a-usar" id="toc-metodología-a-usar" class="nav-link" data-scroll-target="#metodología-a-usar"><span class="header-section-number">2.4</span> Metodología a usar</a></li>
  </ul></li>
  <li><a href="#resultados-y-análisis" id="toc-resultados-y-análisis" class="nav-link" data-scroll-target="#resultados-y-análisis"><span class="header-section-number">3</span> Resultados y Análisis</a></li>
  <li><a href="#aplicación-web" id="toc-aplicación-web" class="nav-link" data-scroll-target="#aplicación-web"><span class="header-section-number">4</span> Aplicación web</a></li>
  <li><a href="#video" id="toc-video" class="nav-link" data-scroll-target="#video"><span class="header-section-number">5</span> Video</a></li>
  <li><a href="#conclusiones" id="toc-conclusiones" class="nav-link" data-scroll-target="#conclusiones"><span class="header-section-number">6</span> Conclusiones</a></li>
  <li><a href="#contribuciones-individuales" id="toc-contribuciones-individuales" class="nav-link" data-scroll-target="#contribuciones-individuales"><span class="header-section-number">7</span> Contribuciones individuales</a></li>
  <li><a href="#referencias" id="toc-referencias" class="nav-link" data-scroll-target="#referencias"><span class="header-section-number">8</span> Referencias</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-right" id="quarto-document-content">




<nav id="TOC-body" role="doc-toc">
    <h2 id="toc-title">Tabla de contenido</h2>
   
  <ul>
  <li><a href="#introducción" id="toc-introducción"><span class="header-section-number">1</span> <strong>Introducción</strong></a></li>
  <li><a href="#marco-teórico" id="toc-marco-teórico"><span class="header-section-number">2</span> <strong>Marco Teórico</strong></a>
  <ul>
  <li><a href="#riesgo-crediticio" id="toc-riesgo-crediticio"><span class="header-section-number">2.1</span> Riesgo crediticio</a>
  <ul>
  <li><a href="#métodos-para-estimar-el-riesgo-crediticio" id="toc-métodos-para-estimar-el-riesgo-crediticio"><span class="header-section-number">2.1.1</span> Métodos para estimar el riesgo crediticio</a></li>
  </ul></li>
  <li><a href="#redes-neuronales-artificiales-rna" id="toc-redes-neuronales-artificiales-rna"><span class="header-section-number">2.2</span> Redes Neuronales Artificiales (RNA)</a>
  <ul>
  <li><a href="#conceptos-clave-en-rna" id="toc-conceptos-clave-en-rna"><span class="header-section-number">2.2.1</span> Conceptos clave en RNA</a></li>
  <li><a href="#rna-en-el-riesgo-crediticio" id="toc-rna-en-el-riesgo-crediticio"><span class="header-section-number">2.2.2</span> RNA en el riesgo crediticio</a></li>
  <li><a href="#ejemplo-básico-en-python" id="toc-ejemplo-básico-en-python"><span class="header-section-number">2.2.3</span> Ejemplo básico en Python</a></li>
  </ul></li>
  <li><a href="#scorecards-y-explicabilidad" id="toc-scorecards-y-explicabilidad"><span class="header-section-number">2.3</span> Scorecards y explicabilidad</a>
  <ul>
  <li><a href="#fórmula-estándar-para-scorecards" id="toc-fórmula-estándar-para-scorecards"><span class="header-section-number">2.3.1</span> Fórmula estándar para scorecards</a></li>
  </ul></li>
  <li><a href="#metodología-a-usar" id="toc-metodología-a-usar"><span class="header-section-number">2.4</span> Metodología a usar</a></li>
  </ul></li>
  <li><a href="#resultados-y-análisis" id="toc-resultados-y-análisis"><span class="header-section-number">3</span> Resultados y Análisis</a></li>
  <li><a href="#aplicación-web" id="toc-aplicación-web"><span class="header-section-number">4</span> Aplicación web</a></li>
  <li><a href="#video" id="toc-video"><span class="header-section-number">5</span> Video</a></li>
  <li><a href="#conclusiones" id="toc-conclusiones"><span class="header-section-number">6</span> Conclusiones</a></li>
  <li><a href="#contribuciones-individuales" id="toc-contribuciones-individuales"><span class="header-section-number">7</span> Contribuciones individuales</a></li>
  <li><a href="#referencias" id="toc-referencias"><span class="header-section-number">8</span> Referencias</a></li>
  </ul>
</nav>
<hr>
<p><strong>ENUCIADO DEL PROBLEMA</strong></p>
<p>El reto en este trabajo es crear un modelo para predecir la probabilidad de que un individuo incumpla con el pago de su crédito.<br>
<br>
La variable “loan_status” (incumplimiento de las obligaciones financieras) está dada en el archivo “Credit Risk Dataset” (disponible en&nbsp;<a href="https://www.kaggle.com/datasets/ranadeep/credit-risk-dataset/data" class="uri">https://www.kaggle.com/datasets/ranadeep/credit-risk-dataset/data</a>).</p>
<p><strong>Reto</strong></p>
<ol type="1">
<li><p>Cree y valide un modelo de probabilidad de incumplimiento basado en redes neuronales artificiales. Optimice la arquitectura del modelo.</p></li>
<li><p>Represente este modelo con una scorecard</p></li>
<li><p>Analice qué variables hacen más riesgosa a una persona</p></li>
<li><p>Cree una app web que le permita saber a las personas, de acuerdo con sus características, cuál es su scorecard y cómo se ve contra la población.</p></li>
</ol>
<hr>
<section id="introducción" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> <strong>Introducción</strong></h1>
<p>El <em>Riesgo de Crédito</em> es un concepto fundamental en las finanzas modernas, ya que representa la posibilidad de que un prestatario incumpla con el pago de una obligación financiera (Financionario, 2025; Finance Strategists, 2023). Su adecuada gestión permite a las instituciones financieras mantener su estabilidad y proyectar confianza ante clientes y reguladores. En la actualidad, la evaluación del riesgo de crédito se apoya cada vez más en modelos de Machine Learning (como las Redes Neuronales), capaces de identificar patrones complejos en grandes volúmenes de datos históricos y así mejorar la toma de decisiones respecto a la aprobación de créditos (ListenData, 2019).</p>
<p>El presente trabajo tiene como objetivo desarrollar un modelo basado en redes neuronales artificiales (RNA) para predecir la probabilidad de incumplimiento de pago de un crédito, utilizando el conjunto de datos “Credit Risk Analysis” (R_G, 2021). Además, se construirá una scorecard derivada del modelo y se implementará una aplicación web interactiva que permita a los usuarios consultar su puntaje y compararse con la población general.</p>
</section>
<section id="marco-teórico" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> <strong>Marco Teórico</strong></h1>
<section id="riesgo-crediticio" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="riesgo-crediticio"><span class="header-section-number">2.1</span> Riesgo crediticio</h2>
<p>El riesgo crediticio se define como la probabilidad de que un prestatario incumpla con el pago de una obligación financiera, lo que puede generar pérdidas para la entidad que otorga el préstamo (Financionario, 2025; Finance Strategists, 2023). Este riesgo es un factor central en la toma de decisiones financieras, ya que afecta tanto a las instituciones como a los solicitantes de crédito. Una gestión adecuada del riesgo crediticio permite anticipar posibles impagos, ajustar condiciones como tasas de interés o garantías, y mantener la estabilidad de las entidades financieras (ListenData, 2019). Además, una evaluación precisa del riesgo crediticio protege a las instituciones de pérdidas inesperadas, promueve la confianza en el sistema financiero y facilita el acceso a condiciones más justas para los usuarios (Finance Strategists, 2023). La correcta evaluación del riesgo es fundamental para la transparencia y eficiencia del sistema financiero, beneficiando a todas las partes involucradas. Por un lado, protege a las instituciones financieras y, por otro, ayuda a los solicitantes a comprender los factores que influyen en su perfil crediticio y a acceder a productos financieros adecuados a su situación (Finance Strategists, 2023).</p>
<p>El riesgo crediticio puede manifestarse en diferentes formas, incluyendo el riesgo de incumplimiento, riesgo de contraparte, riesgo de concentración y riesgo país, entre otros (Pirani Risk, 2022). También se vincula a la calificación crediticia, que evalúa la solvencia de un prestatario y es utilizada por agencias especializadas para informar a inversores y entidades financieras (BME Exchange, s.f.). Para mitigar este riesgo, se aplican estrategias como la diversificación, análisis exhaustivo de crédito, uso de instrumentos de cobertura y monitoreo constante (Pirani Risk, 2022).</p>
<section id="métodos-para-estimar-el-riesgo-crediticio" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="métodos-para-estimar-el-riesgo-crediticio"><span class="header-section-number">2.1.1</span> Métodos para estimar el riesgo crediticio</h3>
<p>La estimación del riesgo crediticio ha evolucionado desde enfoques tradicionales basados en reglas heurísticas y la experiencia de expertos, hasta modelos estadísticos y técnicas avanzadas de machine learning. Entre los métodos más utilizados se encuentran:</p>
<ul>
<li><p><strong>Reglas heurísticas:</strong> Basadas en criterios subjetivos y juicio de analistas, como el modelo de las cinco “C” del crédito (<em>Carácter, Capital, Capacidad, Colateral y Ciclo</em>). Su principal ventaja radica en la simplicidad y facilidad de aplicación, especialmente en contextos donde no se dispone de grandes volúmenes de datos o sistemas automatizados. Además, permite incorporar el conocimiento experto y factores difíciles de cuantificar. Sin embargo, su naturaleza subjetiva limita su capacidad para generalizar y adaptarse a cambios en el entorno económico, lo que puede generar inconsistencias entre evaluadores y dificulta su escalabilidad. Este método es común en pequeñas entidades financieras o microfinancieras donde el análisis personalizado es la norma (De Lara Haro, 2004).</p></li>
<li><p><strong>Modelos estadísticos tradicionales:</strong> La <em>Regresión Logística</em> es uno de los métodos más populares para estimar el riesgo crediticio debido a su capacidad para modelar variables binarias (como incumplimiento o no incumplimiento) y su alta interpretabilidad, lo que facilita la explicación de resultados ante reguladores y gestores (Hosmer &amp; Lemeshow, 2000; ListenData, 2019). El <em>Análisis Discriminante</em> también ha sido empleado en este ámbito, aunque presenta limitaciones cuando el entorno es dinámico o las relaciones entre variables no son lineales (Ince &amp; Aktan, 2009). Estos modelos son ampliamente usados en bancos grandes para <em>scoring</em> crediticio tradicional, pero requieren datos limpios y estructurados, y pueden ser menos efectivos para capturar patrones complejos o interacciones no lineales.</p></li>
<li><p><strong>Modelos basados en calificaciones internas y estructurales:</strong> Métodos como <em>CreditMetrics</em>, desarrollado por J.P. Morgan en 1997, representan un avance al considerar la migración de calificaciones crediticias y la probabilidad de incumplimiento para estimar el valor en riesgo (VaR) de un portafolio. Estos modelos permiten evaluar la diversificación y concentración del riesgo, incorporando además la correlación entre créditos, lo que es crucial para una gestión integral del riesgo crediticio (Sánchez Cerón, 2001). Su principal fortaleza está en modelar la evolución dinámica del riesgo y en su utilidad para la gestión de portafolios y cumplimiento regulatorio. No obstante, requieren grandes volúmenes de datos históricos y matrices de transición bien calibradas, además de presentar cierta complejidad computacional y la necesidad de actualización constante. Son comúnmente utilizados por grandes instituciones financieras para la gestión avanzada del riesgo y la provisión de capital conforme a normativas internacionales (Peña, 2002; Ruza y Paz-Curbera, 2012).</p></li>
<li><p><strong>Técnicas de machine learning:</strong> En los últimos años, las técnicas de aprendizaje automático como <em>Árboles de Decisión, Random Forest, XGBoost y Redes Neuronales Artificiales</em> han ganado protagonismo en la estimación del riesgo crediticio. Estas metodologías destacan por su capacidad para capturar relaciones no lineales y patrones complejos en grandes volúmenes de datos, lo que mejora significativamente la precisión en la predicción del incumplimiento (Zhang, Lipton, Li, &amp; Smola, 2024; Towards Data Science, 2020). Además, permiten automatizar procesos y manejar variables heterogéneas, incluyendo datos no estructurados. Sin embargo, su principal limitación es la menor interpretabilidad respecto a los modelos estadísticos tradicionales, lo que puede dificultar la explicación y aceptación ante organismos reguladores. También requieren recursos computacionales considerables y grandes bases de datos para evitar problemas como el sobreajuste. Estas técnicas son especialmente utilizadas por <em>fintechs</em> y bancos digitales que buscan optimizar la aprobación de créditos mediante modelos predictivos avanzados.</p></li>
</ul>
<p>La selección del método más adecuado para estimar el riesgo crediticio depende del contexto específico, la disponibilidad y calidad de datos, los recursos tecnológicos y las exigencias regulatorias. Mientras que las reglas heurísticas pueden ser útiles en entornos con poca infraestructura tecnológica, los modelos estadísticos y estructurales son preferidos en instituciones con mayor capacidad analítica, y las técnicas de machine learning se posicionan como la vanguardia en escenarios con grandes volúmenes de datos y necesidad de alta precisión.</p>
</section>
</section>
<section id="redes-neuronales-artificiales-rna" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="redes-neuronales-artificiales-rna"><span class="header-section-number">2.2</span> Redes Neuronales Artificiales (RNA)</h2>
<p>Las redes neuronales artificiales (RNA) son modelos computacionales inspirados en la estructura y funcionamiento del cerebro humano, compuestos por nodos interconectados llamados neuronas artificiales, organizados en capas (UNIR, 2021; Zhang, Lipton, Li, &amp; Smola, 2024). Cada neurona recibe señales de entrada, las procesa mediante funciones matemáticas y funciones de activación no lineales, y transmite el resultado a las neuronas de la siguiente capa. Este proceso permite que la red aprenda representaciones jerárquicas y patrones complejos en grandes volúmenes de datos, modelando relaciones no lineales entre variables, lo que resulta especialmente útil en tareas de clasificación, predicción y análisis (IBM, 2021; AWS, 2022; Zhang et al., 2024).</p>
<section id="conceptos-clave-en-rna" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="conceptos-clave-en-rna"><span class="header-section-number">2.2.1</span> Conceptos clave en RNA</h3>
<p><strong>Perceptrón:</strong></p>
<p>El perceptrón es la unidad básica de una red neuronal artificial, constituido por un modelo matemático que recibe un vector de entradas, las multiplica por pesos asociados y suma un sesgo o <em>bias</em>. El resultado de esta suma ponderada se pasa por una función de activación para producir una salida (Zhang et al., 2024, cap. 4).</p>
<p>Matemáticamente, la salida <span class="math inline">\(y\)</span> de una neurona <span class="math inline">\(j\)</span> se expresa como:</p>
<p><span class="math inline">\(y_j = f\left( \sum_i w_{ij} x_i + b_j \right) \tag{1}\)</span></p>
<p>donde <span class="math inline">\(x_i\)</span> son las entradas a la neurona, <span class="math inline">\(w_{ij}\)</span> los pesos asociados a cada entrada, <span class="math inline">\(b_j\)</span> el sesgo (bias) de la neurona, y <span class="math inline">\(f\)</span> la función de activación, que introduce no linealidad necesaria para el aprendizaje. Inicialmente, los pesos (ponderaciones) de la red neuronal se asignan de forma aleatoria, lo que puede generar respuestas erráticas o inconsistentes. A través de un proceso de entrenamiento supervisado, la red ajusta iterativamente estos pesos en función del error entre las predicciones y los resultados reales. Este ciclo de ajuste se repite múltiples veces, permitiendo que la red mejore progresivamente su desempeño hasta alcanzar uno o varios criterios de parada establecidos (IBM, 2021).</p>
<p>El perceptrón fue originalmente propuesto como un clasificador binario, siendo eficiente para problemas linealmente separables, y su concepto se ha extendido para formar la base de redes neuronales más profundas y complejas.</p>
<p><strong>Capas:</strong></p>
<p>Las redes neuronales artificiales (RNA) están organizadas en tres tipos principales de capas:</p>
<ul>
<li><p><strong>Capa de entrada:</strong> Recibe los datos originales o iniciales del problema. Esta capa no realiza cálculos, sino que introduce la información en la red.</p></li>
<li><p><strong>Capas ocultas:</strong> Son una o varias capas intermedias que procesan y transforman la información recibida. Cada neurona en estas capas calcula una suma ponderada de sus entradas, aplica una función de activación no lineal y transmite el resultado a la siguiente capa. El número y tamaño de estas capas determinan la capacidad de la red para aprender representaciones jerárquicas y patrones complejos.</p></li>
<li><p><strong>Capa de salida:</strong> Produce la predicción final, que puede ser una clase, una probabilidad o un valor numérico, según el tipo de problema (clasificación, regresión, etc.).</p></li>
</ul>
<p>La profundidad y arquitectura de la red se seleccionan en función de la complejidad del problema y la cantidad de datos disponibles. La arquitectura define cómo se conectan las neuronas y cómo fluye la información, siendo un aspecto clave para el desempeño del modelo (Zhang et al., 2024; Interactive Chaos, 2023; AWS, 2022; GAMCO, 2023).</p>
<p><strong>Funciones de activación:</strong></p>
<p>Las funciones de activación transforman la salida de cada nodo, permitiendo a la red aprender relaciones complejas. La selección de la función de activación es crucial, ya que determina la capacidad del modelo para aproximar funciones no lineales (Zhang et al., 2024, cap. 5).</p>
<p>Existen funciones de activación lineales y no lineales:</p>
<ul>
<li><p><strong>Función lineal</strong><br>
Se define como<br>
<span class="math display">\[ f(x) = x \]</span><br>
Su rango de salida es <span class="math inline">\((-\infty, \infty)\)</span>. Es simple y mantiene la escala de entrada, por lo que se utiliza principalmente en la capa de salida para problemas de regresión. Sin embargo, no introduce no linealidad, lo que limita la capacidad de aprendizaje cuando se usa en capas ocultas.</p></li>
<li><p><strong>Función sigmoide</strong><br>
La función no lineal sigmoide se define como<br>
<span class="math display">\[ f(x) = \frac{1}{1 + e^{-x}} \]</span><br>
Su rango de salida es <span class="math inline">\((0, 1)\)</span>. Es suave y produce salidas interpretables como probabilidades, lo que la hace útil para clasificación binaria. Su principal limitación es el problema del gradiente evanescente, que puede ralentizar el aprendizaje en redes profundas, además de saturarse para valores extremos.</p></li>
<li><p><strong>Tangente hiperbólica</strong><br>
La función no lineal tangente hiperbólica se define como<br>
<span class="math display">\[ f(x) = \tanh(x) = \frac{e^{x} - e^{-x}}{e^{x} + e^{-x}} \]</span>Su rango es <span class="math inline">\((-1, 1)\)</span>. Está centrada en cero, lo que mejora la convergencia respecto a la sigmoide. Sin embargo, también puede sufrir gradiente evanescente y saturación.</p></li>
<li><p><strong>ReLU</strong><br>
La función no lineal ReLU (<em>Rectified Linear Unit</em>, Unidad lineal rectificada)se define como<br>
<span class="math display">\[ f(x) = \max(0, x) \]</span>Su rango es <span class="math inline">\([0, \infty)\)</span>. Es computacionalmente eficiente y ayuda a evitar el problema del gradiente evanescente positivo, facilitando el entrenamiento de redes profundas. Su limitación principal es el problema de neuronas muertas cuando la entrada es negativa de forma persistente.</p></li>
<li><p><strong>Leaky ReLU</strong><br>
La función no lineal Leaky ReLU (<em>Leaky Rectified Linear Unit</em>, ReLU con Fuga), se define como<br>
<span class="math display">\[
f(x) = \begin{cases}
x &amp; \text{si } x &gt; 0 \\
\alpha x &amp; \text{si } x \leq 0
\end{cases}
\]</span><br>
con <span class="math inline">\(\alpha\)</span> pequeño (por ejemplo, 0.01). Su rango es <span class="math inline">\((-\infty, \infty)\)</span>. Soluciona el problema de neuronas muertas permitiendo una pequeña pendiente para valores negativos. Sin embargo, la elección de <span class="math inline">\(\alpha\)</span> es arbitraria y no siempre mejora todos los modelos.</p></li>
<li><p><strong>Softmax</strong><br>
Para un vector <span class="math inline">\(\mathbf{x}\)</span>, la función no lineal softmax se define como<br>
<span class="math display">\[
f_i(\mathbf{x}) = \frac{e^{x_i}}{\sum_j e^{x_j}} \quad \text{para } i=1,...,K
\]</span><br>
Su rango es <span class="math inline">\((0, 1)\)</span> y suma total 1. Es usada en la capa de salida para clasificación multiclase, convirtiendo vectores en distribuciones de probabilidad. Su limitación es que puede ser costosa computacionalmente para muchas clases.</p></li>
<li><p><strong>ELU</strong></p>
<p>La función no lineal ELU (<em>Exponential Linear Unit</em>, Unidad Lineal Exponencial) se define como<br>
<span class="math display">\[
f(x) = \begin{cases}
x &amp; \text{si } x &gt; 0 \\
\alpha (e^{x} - 1) &amp; \text{si } x \leq 0
\end{cases}
\]</span><br>
con <span class="math inline">\(\alpha &gt; 0\)</span>. Su rango es <span class="math inline">\((-\alpha, \infty)\)</span>. Converge rápido, tiene salida centrada cerca de cero y evita neuronas muertas. Su cálculo es más costoso que ReLU y <span class="math inline">\(\alpha\)</span> no se aprende durante el entrenamiento.</p></li>
<li><p><strong>SELU</strong></p>
<p>La función no lineal SELU (<em>Scaled ELU</em>, ELU Escalada) se define como<br>
<span class="math display">\[
f(x) = \lambda \begin{cases}
x &amp; \text{si } x &gt; 0 \\
\alpha (e^{x} - 1) &amp; \text{si } x \leq 0
\end{cases}
\]</span><br>
con <span class="math inline">\(\alpha \approx 1.6733\)</span> y <span class="math inline">\(\lambda \approx 1.0507\)</span> . Su rango es <span class="math inline">\((-\lambda \alpha, \infty)\)</span>. Facilita la auto-normalización interna, acelerando la convergencia y manteniendo media y varianza. Requiere arquitecturas específicas y es sensible a la inicialización.</p></li>
<li><p><strong>Seno</strong><br>
La función no lineal Seno<br>
<br>
<span class="math display">\[ f(x) = \sin(x) \]</span>Su rango es <span class="math inline">\([-1, 1]\)</span>. Es útil para modelar funciones periódicas y patrones complejos, especialmente en señales y series temporales. Su principal limitación es que no es monotónica, lo que puede complicar la optimización.</p></li>
</ul>
<hr>
<p><strong>Nota:</strong> La elección de la función de activación depende del problema y la arquitectura de la red. Por ejemplo, ReLU es la más popular en capas ocultas por su eficiencia y buen desempeño, mientras que sigmoide y softmax se usan comúnmente en la capa de salida para clasificación.</p>
</section>
<section id="rna-en-el-riesgo-crediticio" class="level3" data-number="2.2.2">
<h3 data-number="2.2.2" class="anchored" data-anchor-id="rna-en-el-riesgo-crediticio"><span class="header-section-number">2.2.2</span> RNA en el riesgo crediticio</h3>
<p>El teorema de aproximación universal establece que una red neuronal con una sola capa oculta y suficientes neuronas puede aproximar cualquier función continua definida en un conjunto compacto, siempre que utilice funciones de activación no lineales (Zhang et al., 2024, cap. 5; Cloudflare, 2023). En la práctica, para problemas complejos como el riesgo crediticio, se emplean arquitecturas más profundas y técnicas modernas de regularización y optimización, lo que permite capturar interacciones sutiles entre variables demográficas, financieras y de comportamiento.</p>
<p>En el sector financiero, las RNA han demostrado ser especialmente útiles para la clasificación de clientes según su nivel de riesgo, la predicción de incumplimientos y la asignación de puntajes crediticios personalizados (Towards Data Science, 2020). Sin embargo, su implementación requiere un preprocesamiento cuidadoso y técnicas de explicabilidad para cumplir con normativas y generar confianza en reguladores y usuarios finales.</p>
</section>
<section id="ejemplo-básico-en-python" class="level3" data-number="2.2.3">
<h3 data-number="2.2.3" class="anchored" data-anchor-id="ejemplo-básico-en-python"><span class="header-section-number">2.2.3</span> Ejemplo básico en Python</h3>
<p>Este ejemplo crea una red simple para clasificación binaria con una capa oculta para clasificación binaria, que incluye además la generación de un gráfico visual de la red usando&nbsp;<code>torchviz</code>.&nbsp;</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>C:\Users\Diego\AppData\Local\Programs\Python\PYTHON~1\Lib\site-packages\torch\_subclasses\functional_tensor.py:276: UserWarning: Failed to initialize NumPy: No module named 'numpy' (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\pytorch\torch\csrc\utils\tensor_numpy.cpp:81.)
  cpu = _conversion_method_template(device=torch.device("cpu"))</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>'simple_nn.png'</code></pre>
</div>
<div class="cell-output-display">

</div>
</div>
<p><img src="simple_nn.png" class="img-fluid"></p>
<hr>
</section>
</section>
<section id="scorecards-y-explicabilidad" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="scorecards-y-explicabilidad"><span class="header-section-number">2.3</span> Scorecards y explicabilidad</h2>
<p>Para facilitar la interpretación de los modelos de riesgo crediticio, es común transformar la probabilidad de incumplimiento en un puntaje o&nbsp;<em>scorecard</em>. Este puntaje permite comparar fácilmente el riesgo relativo entre individuos y es ampliamente utilizado en la industria financiera (ListenData, 2019). La conversión a puntaje facilita la toma de decisiones y la comunicación con usuarios y reguladores.</p>
<p>Además, la explicabilidad del modelo es fundamental para cumplir con regulaciones y generar confianza en los usuarios. Por ello, se emplean técnicas como SHAP (<em>SHapley Additive exPlanations</em>), que identifican y cuantifican la influencia de cada variable en la predicción, haciendo los modelos más transparentes y comprensibles.</p>
<section id="fórmula-estándar-para-scorecards" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="fórmula-estándar-para-scorecards"><span class="header-section-number">2.3.1</span> Fórmula estándar para scorecards</h3>
<p>La probabilidad estimada de incumplimiento, <span class="math inline">\(p\)</span>, se transforma en un puntaje mediante la fórmula estándar de score:</p>
<p><span class="math inline">\(Score=200+50\ln\left(\frac{⁡1−p}p\right)\tag{2}\)</span></p>
<p>donde <span class="math inline">\(p\)</span> es la probabilidad de incumplimiento predicha por el modelo. Esta fórmula asigna un puntaje que disminuye a medida que aumenta la probabilidad de incumplimiento, facilitando la clasificación y comparación de clientes según su riesgo.</p>
</section>
</section>
<section id="metodología-a-usar" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="metodología-a-usar"><span class="header-section-number">2.4</span> Metodología a usar</h2>
<p>Para abordar el reto del modelado del riesgo crediticio mediante redes neuronales artificiales, se propone una metodología integral que combina técnicas avanzadas de machine learning con buenas prácticas de ingeniería de datos. Este enfoque se estructura en cinco fases clave, que aseguran la calidad del modelo, su robustez y su interpretabilidad.</p>
<p><strong>1. Análisis exploratorio de datos (EDA)</strong></p>
<p>Antes de construir el modelo, se realiza un análisis exhaustivo para comprender la estructura y calidad del conjunto de datos:</p>
<ul>
<li><p>Evaluación de la distribución de variables, detección y análisis de valores faltantes y outliers.</p></li>
<li><p>Identificación de correlaciones y relaciones entre variables predictoras y la variable objetivo.</p></li>
<li><p>Selección inicial de variables relevantes, excluyendo aquellas con alto porcentaje de datos faltantes o baja relevancia predictiva.</p></li>
<li><p>Visualización de patrones y balance de clases para guiar el preprocesamiento y modelado.</p></li>
</ul>
<p><strong>2. Definición y preprocesamiento de la variable objetivo</strong></p>
<ul>
<li><p>La variable objetivo se define a partir de la columna “loan_status” del dataset, siguiendo la codificación binaria recomendada:</p>
<ul>
<li><p>“Fully Paid” y “Does not meet the credit policy. Status:Fully Paid” codificados como 0 (buenos pagadores).</p></li>
<li><p>“Charged Off”, “Default”, “Late (31-120)”, y “Does not meet the credit policy. Status:Charged Off” codificados como 1 (malos pagadores).</p></li>
<li><p>Se excluyen registros con estados “Current”, “Issued”, “In Grace Period”, “Late (16-30)” y otros marcados como NA, por no tener certeza sobre su comportamiento final.</p></li>
</ul></li>
</ul>
<p><strong>3. Preprocesamiento y preparación de datos</strong></p>
<ul>
<li><p><strong>Tratamiento de valores faltantes:</strong><br>
Imputación múltiple para variables numéricas; estrategias específicas para variables categóricas.</p></li>
<li><p><strong>Ingeniería de características:</strong></p>
<ul>
<li><p>Codificación WoE (Weight of Evidence) para variables categóricas, facilitando la relación con la variable objetivo y la interpretabilidad.</p></li>
<li><p>Escalado robusto (RobustScaler) para variables numéricas, minimizando el impacto de valores atípicos.</p></li>
</ul></li>
<li><p><strong>División de datos:</strong></p>
<ul>
<li><p>División estratificada 80-10-10 para entrenamiento, validación y prueba, manteniendo la proporción de clases.</p></li>
<li><p>Validación cruzada temporal para series temporales, asegurando que los datos de entrenamiento precedan temporalmente a los de validación y prueba, evitando fugas de información.</p></li>
</ul></li>
<li><p><strong>Automatización:</strong><br>
Uso de pipelines para asegurar reproducibilidad y facilitar iteraciones.</p></li>
</ul>
<p><strong>4. Construcción y entrenamiento del modelo</strong></p>
<ul>
<li><p>Diseño de una arquitectura de red neuronal artificial con capas ocultas suficientes para capturar relaciones no lineales complejas.</p></li>
<li><p>Uso de funciones de activación no lineales como ReLU y variantes para mejorar la convergencia y evitar problemas como neuronas muertas.</p></li>
<li><p>Optimización de hiperparámetros mediante técnicas como grid search o búsqueda bayesiana.</p></li>
<li><p>Aplicación de técnicas de regularización (dropout, early stopping) para evitar sobreajuste.</p></li>
<li><p>Implementación y comparación con modelos de baja complejidad como árboles de decisión y regresión logística, para validar mejoras y robustez.</p></li>
</ul>
<p><strong>5. Evaluación y explicabilidad del modelo</strong></p>
<ul>
<li><p>Evaluación con métricas adecuadas para problemas desbalanceados: AUC-ROC, precisión, recall, F1-score.</p></li>
<li><p>Validación cruzada y backtesting para asegurar generalización y estabilidad.</p></li>
<li><p>Pruebas de estrés para evaluar resiliencia ante escenarios adversos.</p></li>
<li><p>Uso de técnicas de explicabilidad como SHAP para identificar variables que más influyen en la predicción, facilitando la interpretación y cumplimiento normativo.</p></li>
<li><p>Transformación de probabilidades en scorecards mediante fórmulas estándar para facilitar la comunicación práctica del riesgo.</p></li>
</ul>
<p><strong>Consideraciones adicionales</strong></p>
<ul>
<li><p>En caso de desbalance significativo, aplicar técnicas como SMOTE o submuestreo para mejorar la detección de casos minoritarios.</p></li>
<li><p>Monitoreo continuo del modelo en producción para detectar degradación y actualizar según sea necesario.</p></li>
<li><p>Documentación rigurosa y cumplimiento de normas APA en el reporte técnico.</p></li>
</ul>
<p>Esta metodología está alineada con las mejores prácticas reportadas en la literatura y la industria para el modelado de riesgo crediticio con redes neuronales (Fernández Castaño, 2007; Grau Álvarez, 2020; FasterCapital, 2025; Eafit, 2021). Su aplicación permitirá construir un modelo robusto, eficiente y transparente para predecir la probabilidad de incumplimiento crediticio.</p>
</section>
</section>
<section id="resultados-y-análisis" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Resultados y Análisis</h1>
<p>En esta sección se presentan los resultados obtenidos al aplicar diferentes métodos de optimización sobre las funciones de Rosenbrock y Rastrigin, tanto en dos como en tres dimensiones. El objetivo fue comparar el desempeño del descenso por gradiente y de tres algoritmos heurísticos: algoritmo genético (GA), optimización por enjambre de partículas (PSO) y evolución diferencial (DE), considerando la calidad de la solución final, el número de evaluaciones de la función objetivo y la robustez frente a condiciones iniciales aleatorias.</p>
</section>
<section id="aplicación-web" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Aplicación web</h1>
<p>Se desarrolló una aplicación web con <em>FastAPI</em>, que permite a los usuarios ingresar sus características personales y recibir su score de riesgo, junto con una comparación frente a la población general y una explicación visual de las variables que más influyen en su resultado.</p>
</section>
<section id="video" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Video</h1>
</section>
<section id="conclusiones" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Conclusiones</h1>
<p>El uso de redes neuronales artificiales permite mejorar la predicción del riesgo de crédito frente a modelos tradicionales, capturando relaciones complejas entre las variables. La construcción de una scorecard facilita la interpretación de los resultados y la toma de decisiones tanto para instituciones financieras como para los propios usuarios. La aplicación web desarrollada aporta valor al permitir la autoevaluación y la transparencia del proceso. Se recomienda continuar explorando técnicas de explicabilidad y monitoreo del modelo para asegurar su robustez y equidad en el tiempo.</p>
<p>El análisis de importancia de variables mediante SHAP reveló que el historial crediticio, el ingreso mensual y la relación deuda/ingreso son los factores más determinantes para el riesgo de incumplimiento.</p>
</section>
<section id="contribuciones-individuales" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Contribuciones individuales</h1>
<ul>
<li><p><strong><em>Diego Chávez:</em></strong> Mis contribuciones al proyecto …</p></li>
<li><p><strong><em>Alejandro Feria:</em></strong> Redaccion …</p></li>
<li><p><strong><em>Santiago Molina</em>:</strong> Diseñar e implementar …</p></li>
<li><p><strong><em>Juan Teherán:</em></strong> Los aportes …</p></li>
</ul>
</section>
<section id="referencias" class="level1" data-number="8">
<h1 data-number="8"><span class="header-section-number">8</span> Referencias</h1>
<div class="bibliografia-apa">
<p>Asesoftware. (2024). Redes Neuronales Artificiales: Funciones y aplicaciones en IA. https://asesoftware.com/redes-neuronales-artificiales/<br></p>
<p>AWS. (2022).&nbsp;<em>Machine Learning Techniques for Credit Risk Analysis</em>. Amazon Web Services.<br></p>
<p>AWS. (2022). ¿Qué es una red neuronal? https://aws.amazon.com/es/what-is/neural-network/<br></p>
<p>BME Exchange. (s.f.).&nbsp;<em>Calificación crediticia</em>.&nbsp;<a href="https://www.bmexchange.com/">https://www.bmexchange.com</a><br></p>
<p>Cloudflare. (2023). What is a neural network? <a href="https://www.cloudflare.com/learning/ddos/glossary/neural-network/" class="uri">https://www.cloudflare.com/learning/ddos/glossary/neural-network/</a><br></p>
<p>De Lara Haro, F. (2004).&nbsp;<em>Gestión del riesgo crediticio</em>. Editorial Universitaria.<br></p>
<p>Fernández Castaño, H., &amp; Pérez Ramírez, F. O. (2007).&nbsp;<em>Las redes neuronales y la evaluación del riesgo de crédito</em>. Revista Ingenierías, Universidad de Medellín, 6(10), 77–91.&nbsp;<a href="https://revistas.udem.edu.co/index.php/ingenierias/article/view/225" class="uri">https://revistas.udem.edu.co/index.php/ingenierias/article/view/225</a><br></p>
<p>Finance Strategists. (2023). Credit risk: Definition, types, and management. <a href="https://www.financestrategists.com/" class="uri">https://www.financestrategists.com/</a><br></p>
<p>Financionario. (2025). ¿Qué es el riesgo de crédito? <a href="https://www.financionario.com/" class="uri">https://www.financionario.com/</a></p>
<p>GAMCO. (2023). Qué es Arquitectura de red neuronal Concepto y definición. Glosario. https://gamco.es/glosario/arquitectura-de-red-neuronal/<br></p>
<p>Gómez Ramírez, N. A., Guerrero Velandia, G. C., &amp; Prieto Ardila, Y. A. (2020). Diseño de un modelo teórico de análisis crediticio usando redes neuronales artificiales aplicadas a Start-ups. Universidad EAN.&nbsp;<a href="https://repository.universidadean.edu.co/bitstreams/145bb004-8f26-4d1e-b632-065627cdbb06/download" class="uri">https://repository.universidadean.edu.co/bitstreams/145bb004-8f26-4d1e-b632-065627cdbb06/download</a><br></p>
<p>Hosmer, D. W., &amp; Lemeshow, S. (2000).&nbsp;<em>Applied logistic regression</em>&nbsp;(2nd ed.). Wiley.<br></p>
<p>IBM. (2021). El modelo de redes neuronales. https://www.ibm.com/docs/es/spss-modeler/saas?topic=networks-neural-model<br></p>
<p>IBM. (2021).&nbsp;<em>Understanding Neural Networks for Credit Risk</em>. IBM Documentation.<br></p>
<p>IBM. (2025). What are artificial neural networks? <a href="https://www.ibm.com/cloud/learn/neural-networks" class="uri">https://www.ibm.com/cloud/learn/neural-networks</a><br></p>
<p>Ince, H., &amp; Aktan, B. (2009).&nbsp;<em>Credit risk evaluation with discriminant analysis</em>. Journal of Financial Studies.<br></p>
<p>Interactive Chaos. (2023). Estructura de una red neuronal. https://interactivechaos.com/es/manual/tutorial-de-machine-learning/estructura-de-una-red-neuronal<br></p>
<p>ListenData. (2019). A complete guide to credit risk modelling. <a href="https://www.listendata.com/2019/08/credit-risk-modelling.html" class="uri">https://www.listendata.com/2019/08/credit-risk-modelling.html</a><br></p>
<p>Pirani Risk. (2022).&nbsp;<em>Gestión integral del riesgo crediticio</em>.&nbsp;<a href="https://www.piranirisk.com/">https://www.piranirisk.com</a><br></p>
<p>R_G. (2021). Credit risk analysis [Dataset]. Kaggle. <a href="https://www.kaggle.com/datasets/ranadeep/credit-risk-dataset/data" class="uri">https://www.kaggle.com/datasets/ranadeep/credit-risk-dataset/data</a><br></p>
<p>Sánchez Cerón, F. (2001).&nbsp;<em>Modelos estructurales para la gestión del riesgo de crédito</em>. Editorial Financiera.<br></p>
<p>Towards Data Science. (2020). How to prepare data for credit risk modeling. <a href="https://towardsdatascience.com/how-to-prepare-data-for-credit-risk-modeling-5523641882f2/" class="uri">https://towardsdatascience.com/how-to-prepare-data-for-credit-risk-modeling-5523641882f2/</a><br></p>
<p>UNIR. (2021). Redes neuronales artificiales: Qué son y para qué sirven. <a href="https://www.unir.net/tecnologia/revista/redes-neuronales-artificiales/" class="uri">https://www.unir.net/tecnologia/revista/redes-neuronales-artificiales/</a><br></p>
<p>Zhang, A., Lipton, Z. C., Li, M., &amp; Smola, A. J. (2024).&nbsp;<em>Dive into deep learning</em>. Cambridge University Press.&nbsp;<a href="https://d2l.ai/index.html" class="uri">https://d2l.ai/index.html</a><br></p>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>